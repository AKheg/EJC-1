# Lesson 03: Java fields and classes
## Примитивные типа
Java является строго типизированным языком, поэтому у каждой переменной есть свой тип. В соответствии с этим типом она может хранить определённые значения.
Типы в Java делятся на **примитивные** и **ссылочные**.
Существует **8** примитивных типов, как количество битов в байте.

Минимальной единицей информации является **бит**. Он может принимать значение **1** или **0**. По сути, вся информация из себя и представляет набор единиц и нулей, то есть бит. Так как мы работаем с двоичной системой, то значение вычисляется при помощи возведения **2** в определённую степень.

Для вычисления можно следовать следующей логике: 2 в степени 2 (т.е. в квадрате) = 4. Дальше каждая степень является результатом умножения предыдущего числа на 2. Поэтому, получаем следующую цепочку:
``4`` -> ``8`` -> ``16`` -> ``32`` -> ``64`` -> ``128`` -> ``256`` -> ``512`` -> ...
Подробнее можно прочитать в статье "[Примитивные типы в Java](https://sohabr.net/habr/post/261315/)".

####byte####
8 бит объединяются в 1 байт и образуют самый минимальный примитивный тип в Java, называемый **byte**.
++Минимальное значение++: вычисляется как 2 со знаком минус в степени, на единицу 
меньшей чем число бит, т.е. -2^7. Как мы видели ранее, это -128.
++Максимальное значение++: 2 в степени меньшей на единицу, чем число бит и минус 1. Т.е. 2^7 - 1 = 128-1 = 127

####short####
Дальше размер примитивных типов возрастает в 2 раза. Поэтому следующий тип - **short**. Можно запомнить, как тип, который короче чем стандартный **integer**. Его размер больше чем байт в 2 раза, т.е. 8*2=16, но меньше чем integer в 2 раза.
++Минимальное значение++: -2^15
++Максимальное значение++: 2^15-1

####integer####
Следующий примитивный тип - **integer**. Он в 2 раза больше, чем short и равен 32 битам.
++Минимальное значение++: -2^31
++Максимальное значение++: 2^31-1
Это почти 2 с девятью нулями, даже больше.
В интернете можно найти сведения, например в статье "[Примитивные типы в Java](https://sohabr.net/habr/post/261315/)", что при выполнении действий с short и byte они будут приведены к integer (так называемое **расширяющее преобразование**).

####long####
Если по какой-то причине integer'а нехватает, то есть тип данных, больший чем integer в 2 раза и называемый long. Соответственно, его значения от -2^63 до 2^63-1.

###Числа с плавающей точкой (действительные)###
Реализованы в Java в виде двух примитивных типов: **float** и **double**.
Первый из них является **32**-битовым, а второй - **64**.
Примером может служить число pi из матерматики:
```java
public class FloatAndDouble {
 	public static void main(String[] args) {
        float piValue = (float)Math.PI;
        double piValueExt = Math.PI;
        System.out.println("Float value: "+piValue );
        System.out.println("Double value: "+piValueExt );
    }
}
```
Лишний раз вспомним, что Math - часть пакета java.lang, подключаемый по умолчанию.


###Другие типы###
####char####
Представляет из себя символ и занимает 16 бит (половину от того, что занимает integer).
####boolean####
Хранят логическое значение true или false

##Боксинг (упаковка) и анбоксинг (распаковка)
Начиная с Java1.5 введены автобоксинг и анбоксинг.
Автобоксинг - это упаковка примитивного типа в его объектную обёртку.
Например: ``Integer i = 12;``

И тут стоит не забывать про интересную особенность. Есть некий Constant pool, в котором кэшируются значения Integer. Диапазон кэшируемых значений: -128 до 127. Так как это относится к автобоксингу, то верхняя граница кэшируемых значений может быть настроена при помощи указания параметра JVM: "**-XX:AutoBoxCacheMax**".
```java
public class IntCache {
 	public static void main(String[] args) {
       Integer first = 127;
       Integer second = 127;
       System.out.println(first==second); //True
       first = new Integer(127);
       second = new Integer(127);
       System.out.println(first==second); //False
       first = Integer.valueOf(127);
       second = Integer.valueOf(127);
       System.out.println(first==second); //True
    }
}
```
При использовании параметризированного конструктора будет результат false потому, что мы явно просим создать для нас новый объект. В других вариантах в любом случае будет вызван **valueOf**, который кэширует используемые integer при помощи **java.lang.Integer.IntegerCache**.

Более подробно в статье: "[Autoboxing и unboxing в Java](http://habrahabr.net/habr/329498/)"

##Формат литералов##
Литерал - явно заданное значение. Могут быть указаны следующим образом:
- Десятеричная система: ``10;``
- Шестнадцатеричная система: ``0x1F4``, начинается с ``0x``
```
--> Перевод числа в шестнадцатеричную систему:
500/16: 31 при умножении на 16 даёт 496, 500-496, даёт остаток 4
31/16: можем 16 только умножить на 1, 31-16 даёт остаток 15
Дошли до 1, дальше не продолжаем. 15 это F.
На конце 1. Переворачиваем 4F1 и получаем ответ: 1F4
--> Обратное действует так же:
1F4 состоит из трёх чисел, поэтому:
1*16^2 + 15*16^1 + 4*16^0 = 256 + 240 + 4 = 496 + 4 = 500
```
- Восьмеричная система: ``010``, начинается с нуля.
```
По аналогии с вышеуказанной:
010 = 3 знака
0*8^2 + 1*8^1 + 0*8^0 = 0+8+0 = 8
```
- Двоичная система (начиная с Java7): ``0b101`` ,[начинается с 0b](http://docs.oracle.com/javase/7/docs/technotes/guides/language/binary-literals.html)
```
1*2^2 + 0*2^1 + 1^2^0 = 1*4 + 1 = 5
```
Пример переводов можно также посмотреть в книгах, вроде этой: [Assembler: Учеб. для вузов](https://goo.gl/VNs9xr).

##Базовые операции##
Помимо таких базовых операций как ``+``,``-``,``*``,``/`` есть некоторые другие.
Например, ``77/8`` при делении нам вернёт в int только целую часть.
Чтобы получить int остаток от деления используется %, например:
```java
public static void main(String[] args) {
       int dividend=77;
	   int divider=8;
       int remnant=dividend%divider; 
       System.out.println((dividend/divider)*divider+remnant);
}
```
А также возведение в степень:
```java
public static void main(String[] args) {
       System.out.printf("%d Squared equals %.0f \n", 3, Math.pow(3, 2));
}
```
или наоборот, извлечение корня:
```java
public static void main(String[] args) {
       System.out.printf("2 to the power of %.0f", Math.sqrt(16));
}
```
Остальное можно найти в [java.lang.Math](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html)

###Сдвиги###
Существует несколько видов сдвигов:
- **Сдвиг влево <<**
Например, 3 в двоичной системе: **011**
Сдвигаем на 1 влево и получаем: **110**
Таким образом будет получено число 6.
**Итого:** Сдвиг влево = умножению числа на 2 в степени, равной кол-ву сдвигов
Запомнить, что именно умножение легко: когда увеличивается двоичное число, то разряды добавляются слева. То есть мы растём (умножаемся) **справа налево**
```
3 << 2 = 3*(2^2) = 12, а 3 << 3 = 3*(2^3)= 24
```
- **Сдвиг вправо >>**
Например, 3 в двоичной системе: **011**
Сдвигаем на 1 вправо. 1 при сдвиге вправо становится нулём.
Поэтому в результате 3>>1 мы получим: 000, т.е. ноль
Возьмём интереснее нам число: **10101**, равное 21 в десятичной системе
Сместим вправо на 1, получим: **01010**, равное 10 в десятичной системе
**Итого:** Результат сдвига вправо = деление числа на 2 в степени, равной кол-ву сдвигов
```
10>>2 = 10/2^2 = 10/4 = 2
21>>1 = 21/2^1 = 21/2 = 10.5, int часть 10
```
Cдвиг вправо значения -1 всегда равен -1, поскольку дополнительные знаковые разряды добавляют новые единицы к старшим битам.
- **Побитовое XOR ^**
Результирующий бит, полученный в результате выполнения оператора ^, равен 1, если соответствующий бит только в одном из операндов равен 1. Во всех других случаях результирующий бит равен 0.

Подробнее про сдвиги: [Побитовые операторы](http://developer.alexanderklimov.ru/android/java/bitwise.php)

##Загрузка классов##
Про загрузку классов можно прочитать в статье "[загрузка классов, Class Loader](http://java-se-learning.blogspot.ru/2013/07/class-loader.html)" и статью на хабре "[Загрузка классов в Java. Теория](https://habrahabr.ru/post/103830/)".
Главная особенность подхода к загрузке классов: загружать классы тем загрузчиком, который максимально близко находится к базовому. Это позволяет сначала загружать более доверенные классы, т.е. JRE, каталог lib, а потом всё остальное.
Данный механизм не обеспечивает решение конфликтов в случае дублированных **default** методов в интерфейсах (default методы в интерфейсах добавлены в **Java8**).
Подробнее про интерфейсы и default методы можно прочитать в статье "[Методы по умолчанию в Java 8: что могут и чего не могут?](https://goo.gl/P9SrAX)".

Про инициализацию содержимого класса можно прочитать на stackoverflow:
[Что раньше инициализируется поля класса или конструктор?](https://ru.stackoverflow.com/questions/464028/Что-раньше-инициализируется-поля-класса-или-конструктор)

##Equals и HashCode##
Имея несколько объектов часто хочется понимать, одинаковы ли они.
Причём сравнивать хочется не только нам, как разработчику, но и Java тоже хочет порой знать, один и тот же это объект или разные. Для этого у ``java.lang.Object`` есть два метода: ``Equals`` и ``HashCode``.
Метод **Equals** позволяет определить логику сравнения объектов. Отвечает на вопрос: Эквивалентны ли объекты. Эквивалентные объекты != один и тот же объект.
По умолчанию сравнение происходит **по ссылке**:
```java
public boolean equals(Object obj) {
   return (this == obj);
}
```
Метод **HashCode** позволяет получить **integer** представление объекта, т.е. получить какое-то число, представляющее данный объект.
[JavaDoc HashCode](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--) описывает контракт, реализуемый хэшкодом:
- HashCode одинаков между разными обращениями за HashCode в рамках одного запуска приложения.
- Если 2 объекта равны через Equals, то должны вернуть одинаковый HashCode
- Если 2 объекта не равны через Equals, то необязательно, что они неравны по HashCode. Хотя и говорится, что такого стоит избегать для улучшения производительности в структурах данных, основанных на HashCode.

В случае переопределения HashCode можно получить хэшкод в его изначальном виде, для этого есть метод ``java.lang.System.identityHashCode``, на котором основаны некоторые структуры данных, например: IdentityHashMap.

Базовую реализацию посмотреть не так просто. Метод является **native**.
Более того, способ вычисления HashCode менялся с развитием Java.
Более подробно: [Откуда растут ноги у hashCode](https://m.habrahabr.ru/post/165683/)
Так же статья за 2017 год, 7 февраля: [Как работает hashCode() по умолчанию?](https://m.habrahabr.ru/company/mailru/blog/321306/)
Кратко: на Java6 и Java7 это было случайное число по алгоритму **"Park-Miller RNG"**, в Java8 и 9 это **"Thread-local Xorshift"**, т.е. случайное число по алгоритму horshift на основе состояния потока.
Данные о хэшкоде хранятся в заголовке объекта.
Пример XORShift'a: [Быстрая реализация Random - алгоритм XORShift](http://www.apofig.com/2014/10/random-xorshift.html?m=1).

Так же класс **Object** содержит protected native метод clone для "поверхностного" копирования объектов. Метод помечен protected, чтобы переопределивший его смог расширить область видимости до **public** и указать интерфейс **Cloneable**. Если вызывать clone без указания интерфейса будет: **java.lang.CloneNotSupportedException**
Хороший пример опасности приведён здесь: [Передача и возврат объектов](http://iais.kemsu.ru:8080/odocs/java/AppendixA.html).
ArrayList копирует значения массива при помощи Arrays.copyOf, что влечёт копирование ссылок, а не самих объектов. Поэтому, когда кто-то получит клон - изменения объектов в клоне повлечёт изменение этих объектов в оригинале, т.к. по сути это один и тот же объект. Поэтому более надёжным способом считается сериализация.
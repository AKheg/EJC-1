# Lesson 13: Algorithms: Quick and Radix Sort

## Быстрая сортировка (Quick Sort)
Более сложным алгоритмом сортировки является алгоритм под названием: Быстрая сортировка. Она же сортировка Хоара.
Интересно, что алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой русско-английского разговорника.

Хороший и подробный разбор представлен в статье на medium.com: "[Информатика в JavaScript: Быстрая сортировка (Quicksort)](https://medium.com/devschacht/nicholas-c-zakas-computer-science-in-javascript-quicksort-afa07c0a47f0)".

Как в старых добрых задачах. Из пункта А в пункт Б направился маркер. Ему на встречу из пункта Б в пункт А направился другой маркер )

Определены начальный элемент ``first`` и ``last`` - границы, в которых мы работаем. При первой итерации мы имеем не разделённый (логически) массив, поэтому они равны началу и концу массива.


Выбирается опорный элемент (значение элемента массива ```source```), который называют **pivot**:
``` int pivot = source[(first + last) / 2]; ```

Выполняем действия в рамках цикла, **do - while**

Сначала двигаем левый маркер (А). Двигаем, пока его **значение** не станет или больше чем pivot (т.е. требуется перенести элемент вправо), или пока мы не дойдём до самого pivot (т.е. переносить нечего):
``` while (source[leftMarker] < pivot) ```

Потом двигаем правый маркер (Б). Двигаем, пока его **значение** не станет или меньше чем pivot (т.е. требуется перенести элемент влево), или пока мы не дойдём до самого pivot (т.е. переносить нечего):
``` while (source[rightMarker] > pivot) ```

Далее, проверяем, что левый маркер или не дошёл до правого маркера, или они стоят в одном месте: ``` if (leftMarker <= rightMarker) ```
При этом, если левый маркер не дошёл до позиции правого, значит найдены значения для перемещения. Поэтому при ``` if (leftMarker < rightMarker) ``` выполнить замену.
В рамках условия leftMarker <= rightMarker так же увеличиваем каждый маркер на 1.

Выполняем эти действия пока левый маркер меньше или равен правому:
``` while (leftMarker <= rightMarker) ```

Далее мы завершили выполнение для текущей итерации по текущему размеру массива (в самый первый раз, как мы помним, от 0 элемента до последнего).
У нас есть 2 маркера.
Выполняем повторную итерацию по отрезку: от левого маркера до конечной границы (``last``).
Выполняем повторную итерацию по отрезку: от начальной границы ``first`` до правого маркера.
Условие для начала итераций: позиция маркера меньше, чем позиция границы.

При помощи рекурсии выполняются действия для новых отрезков, обозначенными границами прошлой итерации + положением маркера.

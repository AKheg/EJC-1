# Lesson 00: prologue
## Языки программирования
Языки программирования прошли удивительную дорогу и имеют долгую интересную историю.
Одним из первых подходов был **"Императивный"** от слова **imperative**, т.е. приказ.
При таком подходе в исходном коде программы записываются инструкции, которые будут выполнены полсдеовательно. Одним из первых языков программирования высокого уровня стал Fortran (разработан в 1954 году).
Сложность программ росла и была разработана парадигма процедурного программирования. Команды начали объединять в процедуры, описывающие выполняемые шаги. Это позволило добиться лёгкости повторного использования, более лёгкого понимания логики и, соответственно, более лёгкая поддержка больших проектов.
Процедурное программирование - частный случай императивного подхода. Примером процедурных языков программирования можно считать Basic и Pascal.

Шло время, программы росли и что-то надо было менять. И появилась идея объектно ориентированного языка программирования. Основная проблема процедурного языка программирования была в том, что формально процедуры и функции никак между собой не связаны. И Объектно-ориентированного программирование позволило описывать логику, оперируя понятием "объект" и выстраивая связи между объектами.

## Основные принципы ООП
К основным принципам относятся:
- Наследование
Построение иерархии классов, построение классов и объектов на основе других, с получением функциональности базового класса. Позволяет избежать повторяемости кода и построить понятную структуру/иерархию отношений.
- Инкапсуляция
Сокрытие реализации. Обеспечение наибольшей защиты кода для его стабильности. Реализуемый функционал должен предоставлять "на ружу" как можно меньше не нужной информации (внутренние параметры, используемые технологии и т.п.)
- Полиморфизм
Полиморфный - изменчивый. Способность работать с разными объектами без учёта особенностей их реализаций. Или "единообразная обработка разнотипных данных".
- Абстракция
Описание контракта, отделяя концепцию от её реализации.
Яркий пример: спецификации. Например, Java Persistence API - описывает концепцию того, как должны хранится java объекты в базе данных. Эта концепция будет выражена в виде абстрактных классов. Библиотеки же (например, Hibernate) будут отвечать за реализацию.

## Отношения между классами
Обозначение: [UML. Диаграммы классов. Отношения](http://programador.ru/uml-class-diagram-relation/)
Основные отношения:
- Агрегация (обозначается пустым ромбом у того, кто хранит поле)
Объект в себе содержит другой объект, но при этом не управляет временем жизни этого объекта
- Композиация (обозначается закрашенным ромбом)
Объект в себе содержит другой объект, но при этом полностью управляет временем жизни этого объекта. Объект не может жить отдельно от того класса, частью композиции которого он является
- Ассоциация (просто стрелка)
Один объект ссылается на другой, т.е. имеет на него ссылку, но не содержит его в себе

## Раннее и позднее связывание
Существуют такие понятие, как ранние связывание и позднее связывание.
Раннее связывание - выполняется на этапе компиляции (Compile time).
Позднее связывание - выполняется в момент выполнения (Runtime).

Подробнее: "[How the Java virtual machine handles method invocation and return](http://www.javaworld.com/article/2076949/learn-java/how-the-java-virtual-machine-handles-method-invocation-and-return.html)".
```
When the Java virtual machine invokes a class method, it selects the method to invoke based on the type of the object reference, which is always known at compile-time.

On the other hand, when the virtual machine invokes an instance method, it selects the method to invoke based on the actual class of the object, which may only be known at run time.

The JVM uses two different instructions, shown in the following table, to invoke these two different kinds of methods: invokevirtual for instance methods, and invokestatic for class methods.
```
Получается, что позднее связывание = метод объекта = invokevirtual
Ранее связывание = метод класса = invokestatic
Как написано на другом ресурса:
```All non-final non-private, not-static methods in Java are virtual```
и
```
The invokespecial instruction is used to invoke instance initialization methods as well as private methods and methods of a superclass of the current class.
```
на основе статьи "[Java Bytecode Fundamentals: Using Objects and Calling Methods](https://zeroturnaround.com/rebellabs/java-bytecode-fundamentals-using-objects-and-calling-methods/)".
Таким образом, полиморфизм становится возможным благодаря механизму позднего связывания.
Для использования динамического (позднего) связывания используется виртуальная таблица методов, своеобразная таблица-развязка. См. "[Virtual tables and abstract in Java](https://stackoverflow.com/questions/9554379/virtual-tables-and-abstract-in-java)"